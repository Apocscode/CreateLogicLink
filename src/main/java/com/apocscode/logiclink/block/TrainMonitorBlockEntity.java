package com.apocscode.logiclink.block;

import com.apocscode.logiclink.LogicLink;
import com.apocscode.logiclink.ModRegistry;
import com.apocscode.logiclink.peripheral.TrainNetworkDataReader;

import net.minecraft.core.BlockPos;
import net.minecraft.core.HolderLookup;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.Tag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.protocol.Packet;
import net.minecraft.network.protocol.game.ClientGamePacketListener;
import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;

import org.jetbrains.annotations.Nullable;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;

/**
 * Block entity for the Train Network Monitor.
 *
 * Responsibilities:
 * - Manages multi-block group state (master/slave, dimensions)
 * - Reads train network data from Create's GlobalRailwayManager via reflection
 * - Caches and syncs display data to client for GUI and TESR rendering
 * - Generates CTC-style network map data from full track topology
 * - Supports switchable display modes (MAP / LIST)
 * - Implements MenuProvider for the right-click GUI
 */
public class TrainMonitorBlockEntity extends BlockEntity implements MenuProvider {

    // ==================== Display Mode ====================
    /** Display modes: 0 = TRAIN LIST, 1 = NETWORK MAP */
    public static final int MODE_LIST = 0;
    public static final int MODE_MAP = 1;
    private int displayMode = MODE_MAP; // default to map

    // ==================== Multi-block State ====================
    private BlockPos masterPos;
    private int monitorWidth = 1;
    private int monitorHeight = 1;

    // ==================== Display Data ====================
    // Overview counters
    private int trainCount = 0;
    private int stationCount = 0;
    private int signalCount = 0;
    private int trainsMoving = 0;
    private int trainsStopped = 0;
    private int trainsDerailed = 0;

    // Train summaries (compact NBT for sync)
    public static final int MAX_DISPLAY_TRAINS = 64;
    private final List<CompoundTag> trainDataList = new ArrayList<>();

    // Station summaries
    public static final int MAX_DISPLAY_STATIONS = 128;
    private final List<CompoundTag> stationDataList = new ArrayList<>();

    // ==================== Map Data (CTC topology) ====================
    /** Full network topology data generated by TrainNetworkDataReader */
    private CompoundTag mapData = new CompoundTag();
    /** Map data refresh is slower — topology doesn't change every tick */
    private int mapRefreshTimer = 599; // start near interval so first refresh fires immediately
    private int mapRefreshInterval = 600; // 30 seconds (topology changes rarely)

    // ==================== Refresh ====================
    private int refreshTimer = 59; // start near interval so first refresh fires quickly
    private int refreshInterval = 60; // 3 seconds for train/station list

    // ==================== Player Proximity ====================
    /** Only refresh data when a player is within this distance (blocks) */
    private static final double PLAYER_RANGE_SQ = 48.0 * 48.0;
    private int proximityCheckTimer = 0;
    private static final int PROXIMITY_CHECK_INTERVAL = 20; // check every 1 second
    private boolean playerNearby = false;

    // ==================== Dirty Tracking (avoid redundant syncs) ====================
    private boolean dataDirty = false;
    private boolean mapDataDirty = false;
    /** Incremented when map data changes; cheaper than CompoundTag.hashCode() */
    private int mapDataVersion = 0;
    /** Incremented when train/station data changes */
    private int trainDataVersion = 0;

    // ==================== Reflection Cache ====================
    private static boolean reflectionInit = false;
    private static boolean reflectionOK = false;

    // Create.RAILWAYS
    private static Field railwaysField;

    // GlobalRailwayManager
    private static Field gmTrainsField;
    private static Field gmTrackNetworksField;
    private static Field gmSignalGroupsField;

    // Train
    private static Field trainNameField;
    private static Field trainSpeedField;
    private static Field trainTargetSpeedField;
    private static Field trainDerailedField;
    private static Field trainCarriagesField;
    private static Field trainNavigationField;
    private static Field trainRuntimeField;
    private static Field trainCurrentStationField;
    private static Field trainFuelTicksField;
    private static Field trainIdField;
    private static Method trainMaxSpeedMethod;
    private static Method trainGetPresentDimensionsMethod;

    // Navigation
    private static Field navDestinationField;
    private static Field navDistanceField;
    private static Method navIsActiveMethod;

    // GlobalStation
    private static Field stationNameField;
    private static Method stationGetPresentTrainMethod;
    private static Method stationGetImminentTrainMethod;
    private static Method stationGetBlockEntityPosMethod;
    private static Method stationGetBlockEntityDimensionMethod;

    // ScheduleRuntime
    private static Field runtimeScheduleField;
    private static Field runtimePausedField;
    private static Method runtimeGetScheduleMethod;

    // Component.getString
    private static Method componentGetStringMethod;

    // ==================== Constructor ====================

    public TrainMonitorBlockEntity(BlockPos pos, BlockState state) {
        super(ModRegistry.TRAIN_MONITOR_BE.get(), pos, state);
        this.masterPos = pos;
    }

    // ==================== Multi-block Accessors ====================

    public boolean isMaster() {
        return worldPosition.equals(masterPos);
    }

    @Nullable
    public TrainMonitorBlockEntity getMaster() {
        if (isMaster()) return this;
        if (level == null) return null;
        BlockEntity be = level.getBlockEntity(masterPos);
        return be instanceof TrainMonitorBlockEntity m ? m : null;
    }

    public BlockPos getMasterPos() { return masterPos; }
    public int getMonitorWidth() { return monitorWidth; }
    public int getMonitorHeight() { return monitorHeight; }

    public void setMasterData(BlockPos master, int width, int height) {
        this.masterPos = master;
        this.monitorWidth = width;
        this.monitorHeight = height;
        setChanged();
        if (level != null && !level.isClientSide) {
            BlockState state = getBlockState();
            level.sendBlockUpdated(worldPosition, state, state, 3);
        }
    }

    // ==================== Display Data Accessors ====================

    public int getTrainCount() { return trainCount; }
    public int getStationCount() { return stationCount; }
    public int getSignalCount() { return signalCount; }
    public int getTrainsMoving() { return trainsMoving; }
    public int getTrainsStopped() { return trainsStopped; }
    public int getTrainsDerailed() { return trainsDerailed; }
    public List<CompoundTag> getTrainDataList() { return trainDataList; }
    public List<CompoundTag> getStationDataList() { return stationDataList; }

    // ==================== Display Mode ====================

    public int getDisplayMode() { return displayMode; }

    public void setDisplayMode(int mode) {
        this.displayMode = (mode == MODE_MAP) ? MODE_MAP : MODE_LIST;
        setChanged();
        if (level != null && !level.isClientSide) {
            BlockState state = getBlockState();
            level.sendBlockUpdated(worldPosition, state, state, 3);
        }
    }

    /** Toggle between MAP and LIST modes. Returns new mode. */
    public int toggleDisplayMode() {
        int newMode = (displayMode == MODE_MAP) ? MODE_LIST : MODE_MAP;
        setDisplayMode(newMode);
        return newMode;
    }

    // ==================== Map Data Accessors ====================

    public CompoundTag getMapData() { return mapData; }
    public int getMapDataVersion() { return mapDataVersion; }
    public int getTrainDataVersion() { return trainDataVersion; }

    // ==================== MenuProvider ====================

    @Override
    public Component getDisplayName() {
        return Component.translatable("block.logiclink.train_monitor");
    }

    @Nullable
    @Override
    public AbstractContainerMenu createMenu(int windowId, Inventory inv, Player player) {
        return new TrainMonitorMenu(windowId, inv, masterPos);
    }

    // ==================== Server Tick ====================

    public static void serverTick(Level level, BlockPos pos, BlockState state,
                                   TrainMonitorBlockEntity be) {
        if (!be.isMaster()) return;

        // Periodically check if any player is within render distance
        be.proximityCheckTimer++;
        if (be.proximityCheckTimer >= PROXIMITY_CHECK_INTERVAL) {
            be.proximityCheckTimer = 0;
            be.playerNearby = level.players().stream().anyMatch(p ->
                    p.blockPosition().distSqr(pos) < PLAYER_RANGE_SQ);
        }

        // Skip data refresh entirely when no player is nearby — biggest TPS saver
        if (!be.playerNearby) return;

        // Train/station list refresh (every ~3 seconds)
        be.refreshTimer++;
        if (be.refreshTimer >= be.refreshInterval) {
            be.refreshTimer = 0;
            be.refreshData();
        }

        // Map topology refresh (every ~30 seconds — topology changes are rare)
        be.mapRefreshTimer++;
        if (be.mapRefreshTimer >= be.mapRefreshInterval) {
            be.mapRefreshTimer = 0;
            be.refreshMapData();
        }

        // Only sync to client when data actually changed
        if (be.dataDirty || be.mapDataDirty) {
            be.dataDirty = false;
            be.mapDataDirty = false;
            level.sendBlockUpdated(pos, state, state, 3);
        }
    }

    // ==================== Data Reading (Reflection) ====================

    private void refreshData() {
        if (!reflectionInit) initReflection();
        if (!reflectionOK) return;

        try {
            Object manager = railwaysField.get(null);
            if (manager == null) return;

            readTrainData(manager);
            readStationData(manager);
            readSignalCount(manager);
        } catch (Exception e) {
            LogicLink.LOGGER.debug("TrainMonitor: Failed to read train data: {}", e.getMessage());
        }
    }

    /** Refresh full network topology for CTC map display */
    private void refreshMapData() {
        try {
            CompoundTag newData = TrainNetworkDataReader.readNetworkMap(level);
            if (newData != null && !newData.isEmpty()) {
                // Quick size check before expensive comparison — if key counts differ, definitely changed
                boolean changed = mapData.isEmpty()
                        || newData.getAllKeys().size() != mapData.getAllKeys().size();
                if (!changed) {
                    // Compare node/edge/train counts as a fast proxy for change detection
                    changed = getListSize(newData, "Nodes") != getListSize(mapData, "Nodes")
                           || getListSize(newData, "Trains") != getListSize(mapData, "Trains")
                           || getListSize(newData, "Signals") != getListSize(mapData, "Signals");
                }
                if (!changed) {
                    // Check if any train position/speed changed (most frequent change)
                    changed = trainDataChanged(newData);
                }
                if (changed) {
                    mapData = newData;
                    mapDataVersion++;
                    mapDataDirty = true;
                    LogicLink.LOGGER.debug("TrainMonitor: Map data updated v{} — {} keys",
                            mapDataVersion, newData.getAllKeys().size());
                }
            } else {
                LogicLink.LOGGER.debug("TrainMonitor: readNetworkMap returned empty/null data");
            }
        } catch (Exception e) {
            LogicLink.LOGGER.debug("TrainMonitor: Failed to read map data: {}", e.getMessage());
        }
    }

    /** Fast check if train positions/speeds changed between old and new map data */
    private boolean trainDataChanged(CompoundTag newData) {
        if (!newData.contains("Trains") || !mapData.contains("Trains")) return true;
        ListTag newTrains = newData.getList("Trains", 10);
        ListTag oldTrains = mapData.getList("Trains", 10);
        if (newTrains.size() != oldTrains.size()) return true;
        for (int i = 0; i < newTrains.size(); i++) {
            CompoundTag nt = newTrains.getCompound(i);
            CompoundTag ot = oldTrains.getCompound(i);
            if (Math.abs(nt.getFloat("x") - ot.getFloat("x")) > 0.5f) return true;
            if (Math.abs(nt.getFloat("z") - ot.getFloat("z")) > 0.5f) return true;
            if (Math.abs(nt.getDouble("speed") - ot.getDouble("speed")) > 0.01) return true;
        }
        return false;
    }

    private static int getListSize(CompoundTag tag, String key) {
        return tag.contains(key) ? tag.getList(key, 10).size() : 0;
    }

    private void readTrainData(Object manager) throws Exception {
        @SuppressWarnings("unchecked")
        Map<UUID, Object> trains = (Map<UUID, Object>) gmTrainsField.get(manager);
        if (trains == null) return;

        trainDataList.clear();
        int moving = 0, stopped = 0, derailed = 0;

        for (Object train : trains.values()) {
            try {
                CompoundTag tag = new CompoundTag();

                // Name
                Object nameComp = trainNameField.get(train);
                String name = nameComp != null ? (String) componentGetStringMethod.invoke(nameComp) : "Unknown";
                tag.putString("name", name);

                // Speed
                double speed = trainSpeedField.getDouble(train);
                tag.putDouble("speed", speed);

                // Derailed
                boolean isDerailed = trainDerailedField.getBoolean(train);
                tag.putBoolean("derailed", isDerailed);

                // Carriages count
                List<?> carriages = (List<?>) trainCarriagesField.get(train);
                tag.putInt("carriages", carriages != null ? carriages.size() : 0);

                // Current station
                Object currentStation = trainCurrentStationField.get(train);
                if (currentStation != null) {
                    String stName = (String) stationNameField.get(currentStation);
                    if (stName != null) tag.putString("currentStation", stName);
                }

                // Navigation
                Object nav = trainNavigationField.get(train);
                boolean navigating = false;
                if (nav != null) {
                    navigating = (boolean) navIsActiveMethod.invoke(nav);
                    tag.putBoolean("navigating", navigating);
                    if (navigating) {
                        Object dest = navDestinationField.get(nav);
                        if (dest != null) {
                            String destName = (String) stationNameField.get(dest);
                            if (destName != null) tag.putString("destination", destName);
                        }
                        double dist = navDistanceField.getDouble(nav);
                        tag.putDouble("distance", dist);
                    }
                }

                // Schedule
                Object runtime = trainRuntimeField.get(train);
                boolean hasSchedule = false;
                if (runtime != null) {
                    Object schedule = runtimeGetScheduleMethod.invoke(runtime);
                    hasSchedule = schedule != null;
                    tag.putBoolean("hasSchedule", hasSchedule);
                }

                // UUID (truncated for display)
                UUID id = (UUID) trainIdField.get(train);
                if (id != null) tag.putString("id", id.toString().substring(0, 8));

                trainDataList.add(tag);

                // Count states
                if (isDerailed) derailed++;
                else if (Math.abs(speed) > 0.01) moving++;
                else stopped++;

            } catch (Exception e) {
                // Skip this train on error
            }

            if (trainDataList.size() >= MAX_DISPLAY_TRAINS) break;
        }

        // Sort: derailed first, then moving, then stopped
        trainDataList.sort((a, b) -> {
            int aDerailed = a.getBoolean("derailed") ? 0 : 1;
            int bDerailed = b.getBoolean("derailed") ? 0 : 1;
            if (aDerailed != bDerailed) return aDerailed - bDerailed;
            double aSpeed = Math.abs(a.getDouble("speed"));
            double bSpeed = Math.abs(b.getDouble("speed"));
            return Double.compare(bSpeed, aSpeed); // faster first
        });

        // Check if data actually changed before marking dirty
        boolean changed = (trainCount != trains.size()) ||
                (trainsMoving != moving) || (trainsStopped != stopped) || (trainsDerailed != derailed);
        trainCount = trains.size();
        trainsMoving = moving;
        trainsStopped = stopped;
        trainsDerailed = derailed;
        if (changed) {
            dataDirty = true;
            trainDataVersion++;
        }
    }

    // ==================== Station Reflection Cache ====================
    private static Object cachedStationType = null;
    private static Method cachedGetPointsMethod = null;
    private static Class<?> cachedEdgePointTypeClass = null;

    private void readStationData(Object manager) throws Exception {
        stationDataList.clear();

        // Get track networks and iterate their station edge points
        @SuppressWarnings("unchecked")
        Map<UUID, Object> networks = (Map<UUID, Object>) gmTrackNetworksField.get(manager);
        if (networks == null) return;

        // Collect all stations from all track graphs
        try {
            // Cache the EdgePointType reflection — avoid re-discovering every refresh
            if (cachedStationType == null) {
                cachedEdgePointTypeClass = Class.forName("com.simibubi.create.content.trains.graph.EdgePointType");
                Field stationTypeField = cachedEdgePointTypeClass.getDeclaredField("STATION");
                stationTypeField.setAccessible(true);
                cachedStationType = stationTypeField.get(null);
            }

            for (Object graph : networks.values()) {
                try {
                    if (cachedGetPointsMethod == null) {
                        cachedGetPointsMethod = graph.getClass().getMethod("getPoints", cachedEdgePointTypeClass);
                    }
                    Collection<?> points = (Collection<?>) cachedGetPointsMethod.invoke(graph, cachedStationType);
                    if (points == null) continue;

                    for (Object station : points) {
                        if (stationDataList.size() >= MAX_DISPLAY_STATIONS) break;

                        try {
                            CompoundTag tag = new CompoundTag();
                            String name = (String) stationNameField.get(station);
                            tag.putString("name", name != null ? name : "Unknown");

                            // Position
                            BlockPos sPos = (BlockPos) stationGetBlockEntityPosMethod.invoke(station);
                            if (sPos != null) {
                                tag.putInt("x", sPos.getX());
                                tag.putInt("y", sPos.getY());
                                tag.putInt("z", sPos.getZ());
                            }

                            // Present train
                            Object presentTrain = stationGetPresentTrainMethod.invoke(station);
                            if (presentTrain != null) {
                                Object trainName = trainNameField.get(presentTrain);
                                if (trainName != null) {
                                    tag.putString("trainPresent",
                                            (String) componentGetStringMethod.invoke(trainName));
                                }
                            }

                            stationDataList.add(tag);
                        } catch (Exception e) {
                            // Skip this station
                        }
                    }
                } catch (Exception e) {
                    // Skip this graph
                }
            }
        } catch (Exception e) {
            LogicLink.LOGGER.debug("TrainMonitor: Failed to read stations: {}", e.getMessage());
        }

        // Sort alphabetically
        stationDataList.sort(Comparator.comparing(t -> t.getString("name")));
        if (stationCount != stationDataList.size()) dataDirty = true;
        stationCount = stationDataList.size();
    }

    private void readSignalCount(Object manager) throws Exception {
        @SuppressWarnings("unchecked")
        Map<?, ?> signalGroups = (Map<?, ?>) gmSignalGroupsField.get(manager);
        signalCount = signalGroups != null ? signalGroups.size() : 0;
    }

    // ==================== Reflection Initialization ====================

    private static synchronized void initReflection() {
        if (reflectionInit) return;
        reflectionInit = true;

        try {
            // Create.RAILWAYS
            Class<?> createClass = Class.forName("com.simibubi.create.Create");
            railwaysField = createClass.getDeclaredField("RAILWAYS");
            railwaysField.setAccessible(true);

            // GlobalRailwayManager fields
            Object testManager = railwaysField.get(null);
            if (testManager == null) {
                LogicLink.LOGGER.warn("TrainMonitor: Create.RAILWAYS is null, will retry later");
                reflectionInit = false;
                return;
            }
            Class<?> gmClass = testManager.getClass();
            gmTrainsField = gmClass.getDeclaredField("trains");
            gmTrainsField.setAccessible(true);
            gmTrackNetworksField = gmClass.getDeclaredField("trackNetworks");
            gmTrackNetworksField.setAccessible(true);
            gmSignalGroupsField = gmClass.getDeclaredField("signalEdgeGroups");
            gmSignalGroupsField.setAccessible(true);

            // Train class fields
            Class<?> trainClass = Class.forName("com.simibubi.create.content.trains.entity.Train");
            trainNameField = trainClass.getDeclaredField("name");
            trainNameField.setAccessible(true);
            trainSpeedField = trainClass.getDeclaredField("speed");
            trainSpeedField.setAccessible(true);
            trainTargetSpeedField = trainClass.getDeclaredField("targetSpeed");
            trainTargetSpeedField.setAccessible(true);
            trainDerailedField = trainClass.getDeclaredField("derailed");
            trainDerailedField.setAccessible(true);
            trainCarriagesField = trainClass.getDeclaredField("carriages");
            trainCarriagesField.setAccessible(true);
            trainNavigationField = trainClass.getDeclaredField("navigation");
            trainNavigationField.setAccessible(true);
            trainRuntimeField = trainClass.getDeclaredField("runtime");
            trainRuntimeField.setAccessible(true);
            trainCurrentStationField = trainClass.getDeclaredField("currentStation");
            trainCurrentStationField.setAccessible(true);
            trainFuelTicksField = trainClass.getDeclaredField("fuelTicks");
            trainFuelTicksField.setAccessible(true);
            trainIdField = trainClass.getDeclaredField("id");
            trainIdField.setAccessible(true);

            // Navigation
            Class<?> navClass = Class.forName("com.simibubi.create.content.trains.entity.Navigation");
            navDestinationField = navClass.getDeclaredField("destination");
            navDestinationField.setAccessible(true);
            navDistanceField = navClass.getDeclaredField("distanceToDestination");
            navDistanceField.setAccessible(true);
            navIsActiveMethod = navClass.getMethod("isActive");

            // GlobalStation
            Class<?> stationClass = Class.forName("com.simibubi.create.content.trains.station.GlobalStation");
            stationNameField = stationClass.getDeclaredField("name");
            stationNameField.setAccessible(true);
            stationGetPresentTrainMethod = stationClass.getMethod("getPresentTrain");
            stationGetImminentTrainMethod = stationClass.getMethod("getImminentTrain");
            stationGetBlockEntityPosMethod = stationClass.getMethod("getBlockEntityPos");
            stationGetBlockEntityDimensionMethod = stationClass.getMethod("getBlockEntityDimension");

            // ScheduleRuntime
            Class<?> runtimeClass = Class.forName("com.simibubi.create.content.trains.schedule.ScheduleRuntime");
            runtimeScheduleField = runtimeClass.getDeclaredField("schedule");
            runtimeScheduleField.setAccessible(true);
            runtimePausedField = runtimeClass.getDeclaredField("paused");
            runtimePausedField.setAccessible(true);
            runtimeGetScheduleMethod = runtimeClass.getMethod("getSchedule");

            // Component
            componentGetStringMethod = Component.class.getMethod("getString");

            reflectionOK = true;
            LogicLink.LOGGER.info("TrainMonitor: Create railway reflection initialized successfully");

        } catch (Exception e) {
            LogicLink.LOGGER.error("TrainMonitor: Failed to initialize reflection", e);
            reflectionOK = false;
        }
    }

    // ==================== NBT Persistence ====================

    @Override
    protected void saveAdditional(CompoundTag tag, HolderLookup.Provider registries) {
        super.saveAdditional(tag, registries);
        // Multi-block state
        tag.putInt("MasterX", masterPos.getX());
        tag.putInt("MasterY", masterPos.getY());
        tag.putInt("MasterZ", masterPos.getZ());
        tag.putInt("MonitorWidth", monitorWidth);
        tag.putInt("MonitorHeight", monitorHeight);
        tag.putInt("DisplayMode", displayMode);
        if (refreshInterval != 20) {
            tag.putInt("RefreshInterval", refreshInterval);
        }
    }

    @Override
    protected void loadAdditional(CompoundTag tag, HolderLookup.Provider registries) {
        super.loadAdditional(tag, registries);
        if (tag.contains("MasterX")) {
            masterPos = new BlockPos(tag.getInt("MasterX"), tag.getInt("MasterY"), tag.getInt("MasterZ"));
        } else {
            masterPos = worldPosition;
        }
        monitorWidth = tag.contains("MonitorWidth") ? tag.getInt("MonitorWidth") : 1;
        monitorHeight = tag.contains("MonitorHeight") ? tag.getInt("MonitorHeight") : 1;
        displayMode = tag.contains("DisplayMode") ? tag.getInt("DisplayMode") : MODE_MAP;
        refreshInterval = tag.contains("RefreshInterval") ? tag.getInt("RefreshInterval") : 20;

        // Also load display data — needed for client-side block update packets
        // (onDataPacket -> loadWithComponents -> loadAdditional)
        loadDisplayData(tag);

        // Load map topology data — CRITICAL: sendBlockUpdated() packets
        // go through loadAdditional (not handleUpdateTag), so MapData
        // MUST be loaded here for the client to receive topology updates.
        if (tag.contains("MapData")) {
            mapData = tag.getCompound("MapData").copy();
        }
        if (tag.contains("MapDataVersion")) {
            mapDataVersion = tag.getInt("MapDataVersion");
        }
        if (tag.contains("TrainDataVersion")) {
            trainDataVersion = tag.getInt("TrainDataVersion");
        }
    }

    // ==================== Client Sync ====================

    @Override
    public CompoundTag getUpdateTag(HolderLookup.Provider registries) {
        CompoundTag tag = super.getUpdateTag(registries);
        // Multi-block state — MUST be included so client knows about grouping
        tag.putInt("MasterX", masterPos.getX());
        tag.putInt("MasterY", masterPos.getY());
        tag.putInt("MasterZ", masterPos.getZ());
        tag.putInt("MonitorWidth", monitorWidth);
        tag.putInt("MonitorHeight", monitorHeight);
        tag.putInt("DisplayMode", displayMode);
        // Display data (only master sends this)
        if (isMaster()) {
            saveDisplayData(tag);
            // Include map topology data + version for client-side dirty check
            tag.putInt("MapDataVersion", mapDataVersion);
            tag.putInt("TrainDataVersion", trainDataVersion);
            if (!mapData.isEmpty()) {
                tag.put("MapData", mapData.copy());
            }
        }
        return tag;
    }

    @Override
    public void handleUpdateTag(CompoundTag tag, HolderLookup.Provider registries) {
        super.handleUpdateTag(tag, registries);
        if (tag.contains("DisplayMode")) {
            displayMode = tag.getInt("DisplayMode");
        }
        if (tag.contains("MapDataVersion")) {
            mapDataVersion = tag.getInt("MapDataVersion");
        }
        if (tag.contains("TrainDataVersion")) {
            trainDataVersion = tag.getInt("TrainDataVersion");
        }
        loadDisplayData(tag);
        if (tag.contains("MapData")) {
            mapData = tag.getCompound("MapData").copy();
        }
    }

    @Nullable
    @Override
    public Packet<ClientGamePacketListener> getUpdatePacket() {
        return ClientboundBlockEntityDataPacket.create(this);
    }

    private void saveDisplayData(CompoundTag tag) {
        tag.putInt("DTrainCount", trainCount);
        tag.putInt("DStationCount", stationCount);
        tag.putInt("DSignalCount", signalCount);
        tag.putInt("DMoving", trainsMoving);
        tag.putInt("DStopped", trainsStopped);
        tag.putInt("DDerailed", trainsDerailed);

        // Train list
        ListTag trainList = new ListTag();
        for (CompoundTag t : trainDataList) {
            trainList.add(t.copy());
        }
        tag.put("DTrains", trainList);

        // Station list
        ListTag stationList = new ListTag();
        for (CompoundTag s : stationDataList) {
            stationList.add(s.copy());
        }
        tag.put("DStations", stationList);
    }

    private void loadDisplayData(CompoundTag tag) {
        if (tag.contains("DTrainCount")) {
            trainCount = tag.getInt("DTrainCount");
            stationCount = tag.getInt("DStationCount");
            signalCount = tag.getInt("DSignalCount");
            trainsMoving = tag.getInt("DMoving");
            trainsStopped = tag.getInt("DStopped");
            trainsDerailed = tag.getInt("DDerailed");
        }

        trainDataList.clear();
        if (tag.contains("DTrains")) {
            ListTag list = tag.getList("DTrains", Tag.TAG_COMPOUND);
            for (int i = 0; i < list.size(); i++) {
                trainDataList.add(list.getCompound(i));
            }
        }

        stationDataList.clear();
        if (tag.contains("DStations")) {
            ListTag list = tag.getList("DStations", Tag.TAG_COMPOUND);
            for (int i = 0; i < list.size(); i++) {
                stationDataList.add(list.getCompound(i));
            }
        }
    }
}
