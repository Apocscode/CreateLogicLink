package com.apocscode.logiclink.block;

import com.apocscode.logiclink.LogicLink;
import com.apocscode.logiclink.ModRegistry;
import com.apocscode.logiclink.peripheral.TrainNetworkDataReader;

import net.minecraft.core.BlockPos;
import net.minecraft.core.HolderLookup;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.Tag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.protocol.Packet;
import net.minecraft.network.protocol.game.ClientGamePacketListener;
import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;

import org.jetbrains.annotations.Nullable;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;

/**
 * Block entity for the Train Network Monitor.
 *
 * Responsibilities:
 * - Manages multi-block group state (master/slave, dimensions)
 * - Reads train network data from Create's GlobalRailwayManager via reflection
 * - Caches and syncs display data to client for GUI and TESR rendering
 * - Generates CTC-style network map data from full track topology
 * - Supports switchable display modes (MAP / LIST)
 * - Implements MenuProvider for the right-click GUI
 */
public class TrainMonitorBlockEntity extends BlockEntity implements MenuProvider {

    // ==================== Display Mode ====================
    /** Display modes: 0 = TRAIN LIST, 1 = NETWORK MAP */
    public static final int MODE_LIST = 0;
    public static final int MODE_MAP = 1;
    private int displayMode = MODE_MAP; // default to map

    // ==================== Multi-block State ====================
    private BlockPos masterPos;
    private int monitorWidth = 1;
    private int monitorHeight = 1;

    // ==================== Display Data ====================
    // Overview counters
    private int trainCount = 0;
    private int stationCount = 0;
    private int signalCount = 0;
    private int trainsMoving = 0;
    private int trainsStopped = 0;
    private int trainsDerailed = 0;

    // Train summaries (compact NBT for sync)
    public static final int MAX_DISPLAY_TRAINS = 64;
    private final List<CompoundTag> trainDataList = new ArrayList<>();

    // Station summaries
    public static final int MAX_DISPLAY_STATIONS = 128;
    private final List<CompoundTag> stationDataList = new ArrayList<>();

    // ==================== Map Data (CTC topology) ====================
    /** Full network topology data generated by TrainNetworkDataReader */
    private CompoundTag mapData = new CompoundTag();
    /** Map data refresh is slower — topology doesn't change every tick */
    private int mapRefreshTimer = 0;
    private int mapRefreshInterval = 200; // 10 seconds (topology changes rarely)

    // ==================== Refresh ====================
    private int refreshTimer = 0;
    private int refreshInterval = 40; // 2 seconds for train/station list

    // ==================== Dirty Tracking (avoid redundant syncs) ====================
    private boolean dataDirty = false;
    private int lastMapDataHash = 0;

    // ==================== Reflection Cache ====================
    private static boolean reflectionInit = false;
    private static boolean reflectionOK = false;

    // Create.RAILWAYS
    private static Field railwaysField;

    // GlobalRailwayManager
    private static Field gmTrainsField;
    private static Field gmTrackNetworksField;
    private static Field gmSignalGroupsField;

    // Train
    private static Field trainNameField;
    private static Field trainSpeedField;
    private static Field trainTargetSpeedField;
    private static Field trainDerailedField;
    private static Field trainCarriagesField;
    private static Field trainNavigationField;
    private static Field trainRuntimeField;
    private static Field trainCurrentStationField;
    private static Field trainFuelTicksField;
    private static Field trainIdField;
    private static Method trainMaxSpeedMethod;
    private static Method trainGetPresentDimensionsMethod;

    // Navigation
    private static Field navDestinationField;
    private static Field navDistanceField;
    private static Method navIsActiveMethod;

    // GlobalStation
    private static Field stationNameField;
    private static Method stationGetPresentTrainMethod;
    private static Method stationGetImminentTrainMethod;
    private static Method stationGetBlockEntityPosMethod;
    private static Method stationGetBlockEntityDimensionMethod;

    // ScheduleRuntime
    private static Field runtimeScheduleField;
    private static Field runtimePausedField;
    private static Method runtimeGetScheduleMethod;

    // Component.getString
    private static Method componentGetStringMethod;

    // ==================== Constructor ====================

    public TrainMonitorBlockEntity(BlockPos pos, BlockState state) {
        super(ModRegistry.TRAIN_MONITOR_BE.get(), pos, state);
        this.masterPos = pos;
    }

    // ==================== Multi-block Accessors ====================

    public boolean isMaster() {
        return worldPosition.equals(masterPos);
    }

    @Nullable
    public TrainMonitorBlockEntity getMaster() {
        if (isMaster()) return this;
        if (level == null) return null;
        BlockEntity be = level.getBlockEntity(masterPos);
        return be instanceof TrainMonitorBlockEntity m ? m : null;
    }

    public BlockPos getMasterPos() { return masterPos; }
    public int getMonitorWidth() { return monitorWidth; }
    public int getMonitorHeight() { return monitorHeight; }

    public void setMasterData(BlockPos master, int width, int height) {
        this.masterPos = master;
        this.monitorWidth = width;
        this.monitorHeight = height;
        setChanged();
        if (level != null && !level.isClientSide) {
            BlockState state = getBlockState();
            level.sendBlockUpdated(worldPosition, state, state, 3);
        }
    }

    // ==================== Display Data Accessors ====================

    public int getTrainCount() { return trainCount; }
    public int getStationCount() { return stationCount; }
    public int getSignalCount() { return signalCount; }
    public int getTrainsMoving() { return trainsMoving; }
    public int getTrainsStopped() { return trainsStopped; }
    public int getTrainsDerailed() { return trainsDerailed; }
    public List<CompoundTag> getTrainDataList() { return trainDataList; }
    public List<CompoundTag> getStationDataList() { return stationDataList; }

    // ==================== Display Mode ====================

    public int getDisplayMode() { return displayMode; }

    public void setDisplayMode(int mode) {
        this.displayMode = (mode == MODE_MAP) ? MODE_MAP : MODE_LIST;
        setChanged();
        if (level != null && !level.isClientSide) {
            BlockState state = getBlockState();
            level.sendBlockUpdated(worldPosition, state, state, 3);
        }
    }

    /** Toggle between MAP and LIST modes. Returns new mode. */
    public int toggleDisplayMode() {
        int newMode = (displayMode == MODE_MAP) ? MODE_LIST : MODE_MAP;
        setDisplayMode(newMode);
        return newMode;
    }

    // ==================== Map Data Accessors ====================

    public CompoundTag getMapData() { return mapData; }

    // ==================== MenuProvider ====================

    @Override
    public Component getDisplayName() {
        return Component.translatable("block.logiclink.train_monitor");
    }

    @Nullable
    @Override
    public AbstractContainerMenu createMenu(int windowId, Inventory inv, Player player) {
        return new TrainMonitorMenu(windowId, inv, masterPos);
    }

    // ==================== Server Tick ====================

    public static void serverTick(Level level, BlockPos pos, BlockState state,
                                   TrainMonitorBlockEntity be) {
        if (!be.isMaster()) return;

        // Train/station list refresh (every ~2 seconds)
        be.refreshTimer++;
        if (be.refreshTimer >= be.refreshInterval) {
            be.refreshTimer = 0;
            be.refreshData();
        }

        // Map topology refresh (every ~10 seconds — topology changes are rare)
        be.mapRefreshTimer++;
        if (be.mapRefreshTimer >= be.mapRefreshInterval) {
            be.mapRefreshTimer = 0;
            be.refreshMapData();
        }

        // Only sync to client when data actually changed
        if (be.dataDirty) {
            be.dataDirty = false;
            level.sendBlockUpdated(pos, state, state, 3);
        }
    }

    // ==================== Data Reading (Reflection) ====================

    private void refreshData() {
        if (!reflectionInit) initReflection();
        if (!reflectionOK) return;

        try {
            Object manager = railwaysField.get(null);
            if (manager == null) return;

            readTrainData(manager);
            readStationData(manager);
            readSignalCount(manager);
        } catch (Exception e) {
            LogicLink.LOGGER.debug("TrainMonitor: Failed to read train data: {}", e.getMessage());
        }
    }

    /** Refresh full network topology for CTC map display */
    private void refreshMapData() {
        try {
            CompoundTag newData = TrainNetworkDataReader.readNetworkMap(level);
            if (newData != null && !newData.isEmpty()) {
                int newHash = newData.hashCode();
                if (newHash != lastMapDataHash) {
                    mapData = newData;
                    lastMapDataHash = newHash;
                    dataDirty = true;
                    LogicLink.LOGGER.debug("TrainMonitor: Map data updated — {} keys",
                            newData.getAllKeys().size());
                }
            } else {
                LogicLink.LOGGER.debug("TrainMonitor: readNetworkMap returned empty/null data");
            }
        } catch (Exception e) {
            LogicLink.LOGGER.debug("TrainMonitor: Failed to read map data: {}", e.getMessage());
        }
    }

    private void readTrainData(Object manager) throws Exception {
        @SuppressWarnings("unchecked")
        Map<UUID, Object> trains = (Map<UUID, Object>) gmTrainsField.get(manager);
        if (trains == null) return;

        trainDataList.clear();
        int moving = 0, stopped = 0, derailed = 0;

        for (Object train : trains.values()) {
            try {
                CompoundTag tag = new CompoundTag();

                // Name
                Object nameComp = trainNameField.get(train);
                String name = nameComp != null ? (String) componentGetStringMethod.invoke(nameComp) : "Unknown";
                tag.putString("name", name);

                // Speed
                double speed = trainSpeedField.getDouble(train);
                tag.putDouble("speed", speed);

                // Derailed
                boolean isDerailed = trainDerailedField.getBoolean(train);
                tag.putBoolean("derailed", isDerailed);

                // Carriages count
                List<?> carriages = (List<?>) trainCarriagesField.get(train);
                tag.putInt("carriages", carriages != null ? carriages.size() : 0);

                // Current station
                Object currentStation = trainCurrentStationField.get(train);
                if (currentStation != null) {
                    String stName = (String) stationNameField.get(currentStation);
                    if (stName != null) tag.putString("currentStation", stName);
                }

                // Navigation
                Object nav = trainNavigationField.get(train);
                boolean navigating = false;
                if (nav != null) {
                    navigating = (boolean) navIsActiveMethod.invoke(nav);
                    tag.putBoolean("navigating", navigating);
                    if (navigating) {
                        Object dest = navDestinationField.get(nav);
                        if (dest != null) {
                            String destName = (String) stationNameField.get(dest);
                            if (destName != null) tag.putString("destination", destName);
                        }
                        double dist = navDistanceField.getDouble(nav);
                        tag.putDouble("distance", dist);
                    }
                }

                // Schedule
                Object runtime = trainRuntimeField.get(train);
                boolean hasSchedule = false;
                if (runtime != null) {
                    Object schedule = runtimeGetScheduleMethod.invoke(runtime);
                    hasSchedule = schedule != null;
                    tag.putBoolean("hasSchedule", hasSchedule);
                }

                // UUID (truncated for display)
                UUID id = (UUID) trainIdField.get(train);
                if (id != null) tag.putString("id", id.toString().substring(0, 8));

                trainDataList.add(tag);

                // Count states
                if (isDerailed) derailed++;
                else if (Math.abs(speed) > 0.01) moving++;
                else stopped++;

            } catch (Exception e) {
                // Skip this train on error
            }

            if (trainDataList.size() >= MAX_DISPLAY_TRAINS) break;
        }

        // Sort: derailed first, then moving, then stopped
        trainDataList.sort((a, b) -> {
            int aDerailed = a.getBoolean("derailed") ? 0 : 1;
            int bDerailed = b.getBoolean("derailed") ? 0 : 1;
            if (aDerailed != bDerailed) return aDerailed - bDerailed;
            double aSpeed = Math.abs(a.getDouble("speed"));
            double bSpeed = Math.abs(b.getDouble("speed"));
            return Double.compare(bSpeed, aSpeed); // faster first
        });

        // Check if data actually changed before marking dirty
        boolean changed = (trainCount != trains.size()) ||
                (trainsMoving != moving) || (trainsStopped != stopped) || (trainsDerailed != derailed);
        trainCount = trains.size();
        trainsMoving = moving;
        trainsStopped = stopped;
        trainsDerailed = derailed;
        if (changed) dataDirty = true;
    }

    private void readStationData(Object manager) throws Exception {
        stationDataList.clear();

        // Get track networks and iterate their station edge points
        @SuppressWarnings("unchecked")
        Map<UUID, Object> networks = (Map<UUID, Object>) gmTrackNetworksField.get(manager);
        if (networks == null) return;

        // Collect all stations from all track graphs
        try {
            Class<?> edgePointTypeClass = Class.forName("com.simibubi.create.content.trains.graph.EdgePointType");
            Field stationTypeField = edgePointTypeClass.getDeclaredField("STATION");
            stationTypeField.setAccessible(true);
            Object stationType = stationTypeField.get(null);

            Method getPointsMethod = null;

            for (Object graph : networks.values()) {
                try {
                    if (getPointsMethod == null) {
                        getPointsMethod = graph.getClass().getMethod("getPoints", edgePointTypeClass);
                    }
                    Collection<?> points = (Collection<?>) getPointsMethod.invoke(graph, stationType);
                    if (points == null) continue;

                    for (Object station : points) {
                        if (stationDataList.size() >= MAX_DISPLAY_STATIONS) break;

                        try {
                            CompoundTag tag = new CompoundTag();
                            String name = (String) stationNameField.get(station);
                            tag.putString("name", name != null ? name : "Unknown");

                            // Position
                            BlockPos sPos = (BlockPos) stationGetBlockEntityPosMethod.invoke(station);
                            if (sPos != null) {
                                tag.putInt("x", sPos.getX());
                                tag.putInt("y", sPos.getY());
                                tag.putInt("z", sPos.getZ());
                            }

                            // Present train
                            Object presentTrain = stationGetPresentTrainMethod.invoke(station);
                            if (presentTrain != null) {
                                Object trainName = trainNameField.get(presentTrain);
                                if (trainName != null) {
                                    tag.putString("trainPresent",
                                            (String) componentGetStringMethod.invoke(trainName));
                                }
                            }

                            stationDataList.add(tag);
                        } catch (Exception e) {
                            // Skip this station
                        }
                    }
                } catch (Exception e) {
                    // Skip this graph
                }
            }
        } catch (Exception e) {
            LogicLink.LOGGER.debug("TrainMonitor: Failed to read stations: {}", e.getMessage());
        }

        // Sort alphabetically
        stationDataList.sort(Comparator.comparing(t -> t.getString("name")));
        if (stationCount != stationDataList.size()) dataDirty = true;
        stationCount = stationDataList.size();
    }

    private void readSignalCount(Object manager) throws Exception {
        @SuppressWarnings("unchecked")
        Map<?, ?> signalGroups = (Map<?, ?>) gmSignalGroupsField.get(manager);
        signalCount = signalGroups != null ? signalGroups.size() : 0;
    }

    // ==================== Reflection Initialization ====================

    private static synchronized void initReflection() {
        if (reflectionInit) return;
        reflectionInit = true;

        try {
            // Create.RAILWAYS
            Class<?> createClass = Class.forName("com.simibubi.create.Create");
            railwaysField = createClass.getDeclaredField("RAILWAYS");
            railwaysField.setAccessible(true);

            // GlobalRailwayManager fields
            Object testManager = railwaysField.get(null);
            if (testManager == null) {
                LogicLink.LOGGER.warn("TrainMonitor: Create.RAILWAYS is null, will retry later");
                reflectionInit = false;
                return;
            }
            Class<?> gmClass = testManager.getClass();
            gmTrainsField = gmClass.getDeclaredField("trains");
            gmTrainsField.setAccessible(true);
            gmTrackNetworksField = gmClass.getDeclaredField("trackNetworks");
            gmTrackNetworksField.setAccessible(true);
            gmSignalGroupsField = gmClass.getDeclaredField("signalEdgeGroups");
            gmSignalGroupsField.setAccessible(true);

            // Train class fields
            Class<?> trainClass = Class.forName("com.simibubi.create.content.trains.entity.Train");
            trainNameField = trainClass.getDeclaredField("name");
            trainNameField.setAccessible(true);
            trainSpeedField = trainClass.getDeclaredField("speed");
            trainSpeedField.setAccessible(true);
            trainTargetSpeedField = trainClass.getDeclaredField("targetSpeed");
            trainTargetSpeedField.setAccessible(true);
            trainDerailedField = trainClass.getDeclaredField("derailed");
            trainDerailedField.setAccessible(true);
            trainCarriagesField = trainClass.getDeclaredField("carriages");
            trainCarriagesField.setAccessible(true);
            trainNavigationField = trainClass.getDeclaredField("navigation");
            trainNavigationField.setAccessible(true);
            trainRuntimeField = trainClass.getDeclaredField("runtime");
            trainRuntimeField.setAccessible(true);
            trainCurrentStationField = trainClass.getDeclaredField("currentStation");
            trainCurrentStationField.setAccessible(true);
            trainFuelTicksField = trainClass.getDeclaredField("fuelTicks");
            trainFuelTicksField.setAccessible(true);
            trainIdField = trainClass.getDeclaredField("id");
            trainIdField.setAccessible(true);

            // Navigation
            Class<?> navClass = Class.forName("com.simibubi.create.content.trains.entity.Navigation");
            navDestinationField = navClass.getDeclaredField("destination");
            navDestinationField.setAccessible(true);
            navDistanceField = navClass.getDeclaredField("distanceToDestination");
            navDistanceField.setAccessible(true);
            navIsActiveMethod = navClass.getMethod("isActive");

            // GlobalStation
            Class<?> stationClass = Class.forName("com.simibubi.create.content.trains.station.GlobalStation");
            stationNameField = stationClass.getDeclaredField("name");
            stationNameField.setAccessible(true);
            stationGetPresentTrainMethod = stationClass.getMethod("getPresentTrain");
            stationGetImminentTrainMethod = stationClass.getMethod("getImminentTrain");
            stationGetBlockEntityPosMethod = stationClass.getMethod("getBlockEntityPos");
            stationGetBlockEntityDimensionMethod = stationClass.getMethod("getBlockEntityDimension");

            // ScheduleRuntime
            Class<?> runtimeClass = Class.forName("com.simibubi.create.content.trains.schedule.ScheduleRuntime");
            runtimeScheduleField = runtimeClass.getDeclaredField("schedule");
            runtimeScheduleField.setAccessible(true);
            runtimePausedField = runtimeClass.getDeclaredField("paused");
            runtimePausedField.setAccessible(true);
            runtimeGetScheduleMethod = runtimeClass.getMethod("getSchedule");

            // Component
            componentGetStringMethod = Component.class.getMethod("getString");

            reflectionOK = true;
            LogicLink.LOGGER.info("TrainMonitor: Create railway reflection initialized successfully");

        } catch (Exception e) {
            LogicLink.LOGGER.error("TrainMonitor: Failed to initialize reflection", e);
            reflectionOK = false;
        }
    }

    // ==================== NBT Persistence ====================

    @Override
    protected void saveAdditional(CompoundTag tag, HolderLookup.Provider registries) {
        super.saveAdditional(tag, registries);
        // Multi-block state
        tag.putInt("MasterX", masterPos.getX());
        tag.putInt("MasterY", masterPos.getY());
        tag.putInt("MasterZ", masterPos.getZ());
        tag.putInt("MonitorWidth", monitorWidth);
        tag.putInt("MonitorHeight", monitorHeight);
        tag.putInt("DisplayMode", displayMode);
        if (refreshInterval != 20) {
            tag.putInt("RefreshInterval", refreshInterval);
        }
    }

    @Override
    protected void loadAdditional(CompoundTag tag, HolderLookup.Provider registries) {
        super.loadAdditional(tag, registries);
        if (tag.contains("MasterX")) {
            masterPos = new BlockPos(tag.getInt("MasterX"), tag.getInt("MasterY"), tag.getInt("MasterZ"));
        } else {
            masterPos = worldPosition;
        }
        monitorWidth = tag.contains("MonitorWidth") ? tag.getInt("MonitorWidth") : 1;
        monitorHeight = tag.contains("MonitorHeight") ? tag.getInt("MonitorHeight") : 1;
        displayMode = tag.contains("DisplayMode") ? tag.getInt("DisplayMode") : MODE_MAP;
        refreshInterval = tag.contains("RefreshInterval") ? tag.getInt("RefreshInterval") : 20;

        // Also load display data — needed for client-side block update packets
        // (onDataPacket -> loadWithComponents -> loadAdditional)
        loadDisplayData(tag);

        // Load map topology data — CRITICAL: sendBlockUpdated() packets
        // go through loadAdditional (not handleUpdateTag), so MapData
        // MUST be loaded here for the client to receive topology updates.
        if (tag.contains("MapData")) {
            mapData = tag.getCompound("MapData").copy();
        }
    }

    // ==================== Client Sync ====================

    @Override
    public CompoundTag getUpdateTag(HolderLookup.Provider registries) {
        CompoundTag tag = super.getUpdateTag(registries);
        // Multi-block state — MUST be included so client knows about grouping
        tag.putInt("MasterX", masterPos.getX());
        tag.putInt("MasterY", masterPos.getY());
        tag.putInt("MasterZ", masterPos.getZ());
        tag.putInt("MonitorWidth", monitorWidth);
        tag.putInt("MonitorHeight", monitorHeight);
        tag.putInt("DisplayMode", displayMode);
        // Display data (only master sends this)
        if (isMaster()) {
            saveDisplayData(tag);
            // Include map topology data
            if (!mapData.isEmpty()) {
                tag.put("MapData", mapData.copy());
            }
        }
        return tag;
    }

    @Override
    public void handleUpdateTag(CompoundTag tag, HolderLookup.Provider registries) {
        super.handleUpdateTag(tag, registries);
        if (tag.contains("DisplayMode")) {
            displayMode = tag.getInt("DisplayMode");
        }
        loadDisplayData(tag);
        if (tag.contains("MapData")) {
            mapData = tag.getCompound("MapData").copy();
        }
    }

    @Nullable
    @Override
    public Packet<ClientGamePacketListener> getUpdatePacket() {
        return ClientboundBlockEntityDataPacket.create(this);
    }

    private void saveDisplayData(CompoundTag tag) {
        tag.putInt("DTrainCount", trainCount);
        tag.putInt("DStationCount", stationCount);
        tag.putInt("DSignalCount", signalCount);
        tag.putInt("DMoving", trainsMoving);
        tag.putInt("DStopped", trainsStopped);
        tag.putInt("DDerailed", trainsDerailed);

        // Train list
        ListTag trainList = new ListTag();
        for (CompoundTag t : trainDataList) {
            trainList.add(t.copy());
        }
        tag.put("DTrains", trainList);

        // Station list
        ListTag stationList = new ListTag();
        for (CompoundTag s : stationDataList) {
            stationList.add(s.copy());
        }
        tag.put("DStations", stationList);
    }

    private void loadDisplayData(CompoundTag tag) {
        if (tag.contains("DTrainCount")) {
            trainCount = tag.getInt("DTrainCount");
            stationCount = tag.getInt("DStationCount");
            signalCount = tag.getInt("DSignalCount");
            trainsMoving = tag.getInt("DMoving");
            trainsStopped = tag.getInt("DStopped");
            trainsDerailed = tag.getInt("DDerailed");
        }

        trainDataList.clear();
        if (tag.contains("DTrains")) {
            ListTag list = tag.getList("DTrains", Tag.TAG_COMPOUND);
            for (int i = 0; i < list.size(); i++) {
                trainDataList.add(list.getCompound(i));
            }
        }

        stationDataList.clear();
        if (tag.contains("DStations")) {
            ListTag list = tag.getList("DStations", Tag.TAG_COMPOUND);
            for (int i = 0; i < list.size(); i++) {
                stationDataList.add(list.getCompound(i));
            }
        }
    }
}
